#define NWNX_TOKEN "ODBC2"

// Run on module start
void pSQLInit();

// Run a query
void pQ(string sSQL);
void pSQLQuery(string sSQL);

// Escape and return a string suitable for use in query concatenation
string pE(string str);
string pSQLEscape(string str);

// Begin transaction
// Read the README accompanying the nwnx_pgsql package before
// considering the use of transactions.
void pBegin();

// Commit transaction
void pCommit();

// Rollback transaction
void pRollback(string to_savepoint = "");

// Sets a savepoint.
void pSavepoint(string name);

// Returns the last SQL query executed (globally!).
string pSQLGetLastQuery();

// Fetch next row. Returns 1 on success, 0 on no more rows
int pF();
int pSQLFetch();

// Returns column n in the result set
string pG(int n);
string pSQLGetData(int iCol);
string pGs(int n);

// Returns column n in the result set as int
int pGi(int n);

// Returns column n in the result set as float
float pGf(int n);

// Returns column n in the result set as boolean (0 or 1)
int pGb(int n);

// Return a int formatted for insert or update
string pSi(int n, int b0isNULL = TRUE);

// Return a string formatted for insert or update
string pSs(string s, int bEmptyIsNULL = FALSE);

// Return a float formatted for insert or update
string pSf(float f, int b0isNULL = TRUE);

// Return a bool formatted for insert or update (0 = false, rest = true)
string pSb(int b);

// Stores object with query. Place %s where the object binary data shall go.
void pSCO(string query, object obj);

// Retrieves object with query. Query has to return exactly one value.
object pRCO(string query, location where, object owner = OBJECT_INVALID);

// Returns the last-inserted id.
int pLastID(string table, string column = "id");


// A cursor-query.
string pCursorQ(string query, bool with_hold = false, bool scroll = true, string cursorname = "");

// Close the given cursor
void pCursorClose(string cursor);

// Fetch the given cursor
bool pCursorF(string cursor, string cursor_direction = "next");

/************************************/
/* Implementation                   */
/************************************/

// Functions for initializing APS and working with result sets

void pSQLInit() {
	int i;

	// Placeholder for ODBC persistence
	string sMemory;

	for ( i = 0; i < 8; i++ )  // reserve 8*128 bytes
		sMemory +=
			"................................................................................................................................";
	SetLocalString(GetModule(), "NWNX!" + NWNX_TOKEN + "!SPACER", sMemory);
//	pQ("set search_path = nwserver;");
	pQ("set client_encoding = 'iso-8859-15';");
}

string pSQLGetLastQuery() {
	return GetLocalString(GetModule(), "psql_last_query");
}

void pQ(string sSQL) {
	pSQLQuery(sSQL);
}


void pSQLExecDirect(string sSQL) {
	SetLocalString(GetModule(), "psql_last_query", sSQL);
	SetLocalString(GetModule(), "NWNX!" + NWNX_TOKEN + "!EXEC", sSQL);
}

void pSQLQuery(string sSQL) {
	pSQLExecDirect(sSQL + ";");
}

int pF() {
	return pSQLFetch();
}

int pSQLFetch() {
	string sRow;
	object oModule = GetModule();

	SetLocalString(oModule, "NWNX!" + NWNX_TOKEN + "!FETCH", GetLocalString(oModule, "NWNX!" + NWNX_TOKEN + "!SPACER"));
	sRow = GetLocalString(oModule, "NWNX!" + NWNX_TOKEN + "!FETCH");
	if ( GetStringLength(sRow) > 0 ) {
		SetLocalString(oModule, "NWNX_PGSQL_CurrentRow", sRow);
		return TRUE;
	} else {
		SetLocalString(oModule, "NWNX_PGSQL_CurrentRow", "");
		return FALSE;
	}
}


void pSCO(string query, object obj) {
	SetLocalString(GetModule(), "NWNX!" + NWNX_TOKEN + "!SETSCORCOSQL", query);
	StoreCampaignObject("NWNX", "-", obj);
}

object pRCO(string query, location where, object owner = OBJECT_INVALID) {
	SetLocalString(GetModule(), "NWNX!" + NWNX_TOKEN + "!SETSCORCOSQL", query);
	return RetrieveCampaignObject("NWNX", "-", where, owner);
}


void pBegin() {
	slv_i(MODULE, "psql_transaction", 1);
	pSQLQuery("BEGIN;");
}

void pCommit() {
	pSQLQuery("COMMIT;");
	slv_i(MODULE, "psql_transaction", 0);
}

void pRollback(string to_savepoint = "") {
	if (to_savepoint == "")
		pSQLQuery("ROLLBACK;");
	else
		pSQLQuery("ROLLBACK to savepoint " + to_savepoint + ";");

}

void pSavepoint(string name) {
	pSQLQuery("SAVEPOINT " + name);
}

string pG(int n) {
	return pSQLGetData(n);
}
string pGs(int n) {
	return pSQLGetData(n);
}

int pGi(int n) {
	return StringToInt(pSQLGetData(n));
}

float pGf(int n) {
	return StringToFloat(pSQLGetData(n));
}

int pGb(int n) {
	return pSQLGetData(n) == "t";
}

string pSQLGetData(int iCol) {
	int iPos;
	string sResultSet = GetLocalString(GetModule(), "NWNX_PGSQL_CurrentRow");

	// find column in current row
	int iCount = 0;
	string sColValue = "";

	iPos = FindSubString(sResultSet, "¬");
	if ( ( iPos == -1 ) && ( iCol == 1 ) ) {
		// only one column, return value immediately
		sColValue = sResultSet;
	} else if ( iPos == -1 ) {
		// only one column but requested column > 1
		sColValue = "";
	} else {
		// loop through columns until found
		while ( iCount != iCol ) {
			iCount++;
			if ( iCount == iCol )
				sColValue = GetStringLeft(sResultSet, iPos);
			else {
				sResultSet = GetStringRight(sResultSet, GetStringLength(sResultSet) - iPos - 1);
				iPos = FindSubString(sResultSet, "¬");
			}

			// special case: last column in row
			if ( iPos == -1 )
				iPos = GetStringLength(sResultSet);
		}
	}

	return sColValue;
}

string pE(string str) {
	return pSQLEscape(str);
}
string pSQLEscape(string str) {
	if ( -1 == FindSubString(str, "'") && -1 == FindSubString(str, "\\") )
		return "E'" + str + "'";

	int i = 0; 
	string c = "", new = "'";
	for ( i = 0; i < GetStringLength(str); i++ ) {
		c = GetSubString(str, i, 1);

		if ( c == "'" ) {
			new += "'||chr(39)||'";
		} else if (c == "\\") {
			new += "'||chr(92)||'";
		} else
			new += c;
	}
	new += "'";
	return "E" + new;
}


string pSi(int n, int b0isNULL = TRUE) {
	return b0isNULL && 0 == n ? "NULL" : IntToString(n);
}

string pSs(string s, int bEmptyIsNULL = FALSE) {
	return bEmptyIsNULL && "" == s ? "NULL" : pE(s);
}

string pSf(float f, int b0isNULL = TRUE) {
	return b0isNULL && 0.0 == f ? "NULL" : FloatToString(f);
}

string pSb(int b) {
	return 0 == b ? "'f'" : "'t'";
}

int pLastID(string table, string column = "id") {
	pQ("select currval(pg_get_serial_sequence('" + table + "','" + column + "');");
	if (!pF())
		return 0;
	else
		return pGi(1);
}


int get_next_cursor_serial() {
	int last = lv_i(MODULE, "psql_cursor_serial");
	last++;
	slv_i(MODULE, "psql_cursor_serial", last);
	return last;
}


// A cursor-query.
string pCursorQ(string query, bool with_hold = false, bool scroll = true, string cursorname = "") {
	if ("" == cursorname)
		cursorname = "ps_" + itoa(get_next_cursor_serial());

	pQ("declare " + cursorname + " " + 
			(scroll ? "scroll" : "no scroll") + " " +
		"cursor " +
			(with_hold ? "with hold" : "without hold") + " " +
		"for " + query);
	
	return cursorname;
}

// Close the given cursor
void pCursorClose(string cursor) {
	pQ("close " + cursor);
}

// Fetch the given cursor
bool pCursorF(string cursor, string cursor_direction = "next") {
	pQ("fetch " + cursor_direction + " from " + cursor);
	return pF();
}
