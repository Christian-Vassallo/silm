/*
 * By Bernard 'Elven' Stoeckner <elven@elven.de>
 * Licence: None/Private
 */

extern("inc_mnx")
/*
// Splits a string by sRX, which is a
// posix-compatible regular expression without
// delimiters.
// Example:  mSplitRX("\s+", "this is    a text")
//  would return [this, is, a, text]
// Returns the number of results.
int mSplitRX(string sRX, string sText);


string mSplitResult(int nArg);

// Returns str encoded into base64
string mB64Encode(string str);

// Returns str decoded as base64
string mB64Decode(string str);

// Returns the MD5 hash of str
string mMD5(string str);

// Returns the SHA-1 hash of str
string mSHA1(string str);

// Returns str in camel case.
// Camel Case Looks Like This.
string mGetStringCamelCase(string str);

// Returns str with swapped case.
// Swapped Case -> sWAPPED cASE
string mGetStringSwapCase(string str);

// Returns str desreveR.
string mGetStringReverse(string str);

// Returns str where each occurence of regexp is replaced with replace.
// regexp is to be a POSIX-compatible regular expression.
string mGetStringGSub(string str, string regexp, string replace = "");

// Returns the successor of str.
// See the ruby documentation String#succ for further details.
// Example: "abcd" -> "abce", "test1" -> "test2", "1999zzz" -> "2000aaa", "***" -> "**+"
string mGetStringSucc(string str);

// Returns the crypt() value of str
string mGetStringCrypt(string str, string salt);


// Compares two strings.
// Returns
//   -1 if a < b
//    0 if a = b
//   +1 if a > b
int mStringCompare(string a, string b, int caseSensitive = TRUE);
*/
/* Implementation */

int mCommandSplit(string sText, string sSplitAt = "&&") {
	struct mnxRet r = mnx_synchronous_command(mnx_prepare_command("commandsplit", sText, sSplitAt));
	if ( r.error )
		return 0;

	return StringToInt(r.ret);
}

string mCommandSplitGet(int n) {
	struct mnxRet r = mnx_synchronous_command(mnx_prepare_command("commandget", IntToString(n)));
	if ( r.error )
		return "";

	return r.ret;
}

/*

int mSplitRX(string sRX, string sText) {
	struct mnxRet r = mnx_synchronous_command(mnx_prepare_command("split", sRX, sText));
	if ( r.error )
		return 0;

	return StringToInt(r.ret);
}


string mSplitRXResult(int nArg) {
	struct mnxRet r = mnx_synchronous_command(mnx_prepare_command("splitarg", IntToString(nArg)));
	if ( r.error )
		return "";

	return r.ret;
}


string mB64Encode(string str) {
	struct mnxRet r = mnx_synchronous_command(mnx_prepare_command("B64ENC", str));
	if ( r.error )
		return "";

	return r.ret;
}

string mB64Decode(string str) {
	struct mnxRet r = mnx_synchronous_command(mnx_prepare_command("B64DEC", str));
	if ( r.error )
		return "";

	return r.ret;
}

string mMD5(string str) {
	struct mnxRet r = mnx_synchronous_command(mnx_prepare_command("MD5", str));
	if ( r.error )
		return "";

	return r.ret;
}

string mSHA1(string str) {
	struct mnxRet r = mnx_synchronous_command(mnx_prepare_command("SHA1", str));
	if ( r.error )
		return "";

	return r.ret;
}

string mGetStringCamelCase(string str) {
	struct mnxRet r = mnx_synchronous_command(mnx_prepare_command("STRCAMELCASE", str));
	if ( r.error )
		return "";

	return r.ret;
}

string mGetStringReversed(string str) {
	struct mnxRet r = mnx_synchronous_command(mnx_prepare_command("STRREVERSE", str));
	if ( r.error )
		return "";

	return r.ret;
}

string mGetStringGSub(string str, string regexp, string replace = "") {
	struct mnxRet r = mnx_synchronous_command(mnx_prepare_command("STRGSUB", str, regexp, replace));
	if ( r.error )
		return "";

	return r.ret;
}


string mGetStringSwapCase(string str) {
	struct mnxRet r = mnx_synchronous_command(mnx_prepare_command("STRSWAPCASE", str));
	if ( r.error )
		return "";

	return r.ret;
}

string mGetStringSucc(string str) {
	struct mnxRet r = mnx_synchronous_command(mnx_prepare_command("STRSUCC", str));
	if ( r.error )
		return "";

	return r.ret;
}

string mGetStringCrypt(string str, string salt) {
	struct mnxRet r = mnx_synchronous_command(mnx_prepare_command("STRCRYPT", str, salt));
	if ( r.error )
		return "";

	return r.ret;
}
*/
