#include "inc_pgsql.nh"


#define METADATA_SCHEMA "scorco"
#define METADATA_TABLE "object_metadata"

// Metadata
// ----

struct p_metadata {
	int p_id;
	string resref;
	string tag;
	string name;
	string area_resref;
	string area_tag;
	int hitpoints;
	float x, y, z, f;
};

// Returns p_id if this object has metadata,
// otherwise false.
int p_id(object o = OBJECT_SELF);

// Returns the metadata for this object.
struct p_metadata p_get_metadata_for(object o = OBJECT_SELF);

// Returns the metadata for this id.
struct p_metadata p_get_metadata(int id);

// Returns true if this object can be persisted. This is only
// considering the technical aspects, it does not have to make
// sense.
bool p_canpersist(object o = OBJECT_SELF);

void p_touch(int id);

// Object storage
// ----

// Loads the specified object where it ought to be.
int p_load(struct p_metadata m);

// Saves the object and returns its id,
// returns 0 if the object could not be saved,
// or its id otherwise (be it insert or update).
int p_save(string table, object o = OBJECT_SELF);

// Deletes this object from the database.
// Destroys the objects metadata.
// Does not touch the ingame instance.
// Returns true on success, otherwise false.
bool p_delete(string table, object o = OBJECT_SELF);

// Destroys the given object completely.
// Destroys the objects metadata.
// Use this if you want to get rid of sth.
// Returns true on success, otherwise false.
bool p_destroy(string table, object o = OBJECT_SELF);

// Restores all objects in table matching conditions
// into the game world.
// Returns the number of objects restored.
int p_load_each(string table, string conditions);



// Implementation
// ----


int p_id(object o = OBJECT_SELF) {
	return lv_i(o, "p_id");
}

void p_touch(int id) {
	if (!id) {
		_WARN("cannot touch non-persisted object " + itoa(id));
		return;
	}

	pQ("update " + METADATA_SCHEMA + "." + METADATA_TABLE + " set last_access_on = now() where id = " + pSi(id) + ";");	
}

bool p_canpersist(object o = OBJECT_SELF) {
	return 
		GetIsPC(o) || GetIsDM(o) ||
		GetObjectType(o) == OBJECT_TYPE_ITEM ||
		GetObjectType(o) == OBJECT_TYPE_CREATURE;
}




struct p_metadata p_get_metadata_for(object o = OBJECT_SELF) {
	struct p_metadata md;
	if (!GetIsObjectValid(o)) {
		_WARN("passed NULL object to p_get_metadata.");
		return md;
	}
	int id = p_id(o);

	return p_get_metadata(id);
}


struct p_metadata p_get_metadata(int id) {
	struct p_metadata md;

	if (!id) {
		_FATAL("cannot get metadata for " + itoa(id));
		return md;
	}
	
	md.p_id = id;
	pQ("select resref, tag, name, area_resref, area_tag, hitpoints, x, y, z, f from " + METADATA_SCHEMA + "." + METADATA_TABLE + " " + 
		"where id = " + pSi(id));
	if (!pF()) {
		_FATAL("cannot get metadata for " + itoa(id) + ", id set but no matching row");
	} else {
		md.resref = pG(1);
		md.tag = pG(2);
		md.name = pG(3);
		md.area_resref = pG(4);
		md.area_tag = pG(5);
		md.hitpoints = pGi(6);
		md.x = pGf(7);
		md.y = pGf(8);
		md.z = pGf(9);
		md.f = pGf(10);
	}
	return md;
}


int p_load(struct p_metadata md) {
	vector p = Vector(md.x, md.y, md.z);

	object area = GetObjectByTag(md.area_tag);
	if (!GetIsObjectValid(area)) {
		_WARN("trying to create object in non-existing area " + md.area_tag + "(resref = " + md.area_resref + ")");
	}

	location where = Location(area, p, md.f);
	
	object o = pRCO("select data from " + METADATA_SCHEMA + "." + METADATA_TABLE + " where id = " + pSi(md.p_id) + ";", where);
	
	return GetIsObjectValid(o) && md.p_id;
}


int p_load_each(string table, string conditions) {
    vector p;
	object area;
	int id;
	int total = 0;
    
	pQ("select id, x, y, z, f, area_tag from " + METADATA_SCHEMA + "." + table + " where " + conditions);
    while (pF()) {
        id = pGi(1);
        p = Vector(pGf(2), pGf(3), pGf(4));
        area = GetObjectByTag(pGs(6));
        if (!GetIsObjectValid(area)) {
            _WARN("trying to create object in non-existing area " + pGs(6));
			continue;
        }

        location where = Location(area, p, pGf(5));
        pRCO("select data from " + METADATA_SCHEMA + "." + table + " where id = " + pSi(id) + ";", where);
        total += 1;
    }

    return total;
}



void p_load_each_wrap(string table, string conditions) {
	p_load_each(table, conditions);
}


int p_load_each_in_chunks(string table, string conditions) {
	int chunksize = 50;
	pQ("select count(id) from " + METADATA_SCHEMA + "." + table + " where " + conditions);
	pF();
	
	conditions += " order by id desc";
	int count = pGi(1);
	int iter = 0;
	while (count > 0) {
		DelayCommand(1.0 * iter, 
			p_load_each_wrap(table, conditions + " offset " + itoa(iter * chunksize) + " limit " + itoa(chunksize))
		);	
		iter++;
		count -= chunksize;
	}

	return count;
}


int p_save(string table, object o = OBJECT_SELF) {
	int id = p_id(o);
	
	vector p = GetPosition(o);
	float f = GetFacing(o);

	if (!id) {

		pSCO("insert into " + METADATA_SCHEMA + "." + table + " " +
			"(resref, tag, name, area_resref, area_tag, hitpoints, x, y, z, f, data) values(" +
			pSs(GetResRef(o)) + ", " +
			pSs(GetTag(o)) + ", " +
			pSs(GetName(o)) + ", " +
			pSs(GetResRef(GetArea(o))) + ", " +
			pSs(GetTag(GetArea(o))) + ", " +
			pSi(GetCurrentHitPoints(o)) + ", " +
			pSf(p.x) + ", " +
			pSf(p.y) + ", " +
			pSf(p.z) + ", " +
			pSf(f) + ", " + 
			"%s" + 
		")", o);

		id = pLastId(table, "id");

	} else {

		pSCO("update " + METADATA_SCHEMA + "." + table + " set " +
			"last_access_on = now(), " +
			"resref=" + pSs(GetResRef(o)) + ", " +
			"tag=" + pSs(GetTag(o)) + ", " +
			"name=" + pSs(GetName(o)) + ", " +
			"area_resref=" + pSs(GetResRef(GetArea(o))) + ", " +
			"area_tag=" + pSs(GetTag(GetArea(o))) + ", " +
			"hitpoints=" + pSi(GetCurrentHitPoints(o)) + ", " +
			"x=" + pSf(p.x) + ", " +
			"y=" + pSf(p.y) + ", " +
			"z=" + pSf(p.z) + ", " +
			"f=" + pSf(f) +   ", " + 
			"data = %s " +

			" where id = " + pSi(id)
		, o);
	}

	return id;
}


bool p_delete(string table, object o = OBJECT_SELF) {
	if (!p_id(o)) {
		_FATAL("cannot delete metadata for " + otoa(o) + ", not persistent");
		return 0;
	}
	pQ("delete from " + METADATA_SCHEMA + "." + table + " where id = " + pSi(p_id(o)) + ";");

	dlv_i(o, "p_id");
	return 1;
}

bool p_destroy(string table, object o = OBJECT_SELF) {
	if (!p_delete(table, o)) {
		_WARN("cannot p_delete " + otoa(o) + ", destroying anyways (hehe).");
	}
	DestroyObject(o);
	return 1;
}
