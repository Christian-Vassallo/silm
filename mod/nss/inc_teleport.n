// Show the transporter effect at the given location (with oActivator as the to-be-teleported object).
// This does not show effects at the actual teleport target - you will want to use it twice.
void TeleportEffect(object oActivator, location oLocation);

// Show the dimension door effect visuals.
// Do not use this for cross-area-travel, use TeleportEffect
void DimensionDoorEffect(object oActivator, location lSource, location lTarget);

// Teleports OBJECT_SELF to the given location.
// This will execute immediately. If you want to put it onto the action queue, use AssignCommand(ActionDoCommand()).
void SpellTeleport(location lTarget, bool bVisualsOnly = false);

// Dimension doors OBJECT_SELF to the given location.
// This will execute immediately. If you want to put it onto the action queue, use AssignCommand(ActionDoCommand()).
void SpellDimensionDoor(location lTarget, bool bVisualsOnly = false, bool bShowDistanceTraveled = true);

// Dimension doors (or teleports, if cross-area) OBJECT_SELF to the given location.
// This will execute immediately. If you want to put it onto the action queue, use AssignCommand(ActionDoCommand()).
void SpellDimensionDoorOrTeleport(location lTarget, bool bVisualsOnly = false);


void SpellDimensionDoor(location lTarget, bool bVisualsOnly = false, bool bShowDistanceTraveled = true) {
	DelayCommand(0.4, DimensionDoorEffect(OBJECT_SELF, GetLocation(OBJECT_SELF), lTarget));

	if (!bVisualsOnly) {
		DelayCommand(0.7, JumpToLocation(lTarget));
		if (bShowDistanceTraveled)
			DelayCommand(0.5, FloatingTextStringOnCreature("Distanz: " +
				FloatToString(GetDistanceBetweenLocations(GetLocation(OBJECT_SELF), lTarget), 0, 2) +
				" Meter.", OBJECT_SELF, false)
			);
	}
}


void SpellTeleport(location lTarget, bool bVisualsOnly = false) {
	object teleport = OBJECT_SELF;
	bool inter_area = GetArea(OBJECT_SELF) != GetAreaFromLocation(lTarget);
	float skew = inter_area ? 3.0 : 0.0;

	AssignCommand(teleport, TeleportEffect(teleport, GetLocation(teleport)));
	AssignCommand(teleport, DelayCommand(skew, TeleportEffect(teleport, lTarget)));

	if (!bVisualsOnly) {
		if (true || inter_area) {
			object invis = CreateObject(OBJECT_TYPE_PLACEABLE, "invisobj", lTarget);
			ApplyEffectToObject(DURATION_TYPE_TEMPORARY, EffectVisualEffect(445), invis, skew + 3.0);
			DestroyObject(invis, skew + 4.0);
		}
		DelayCommand(1.1, JumpToLocation(lTarget));
	}
}

void SpellDimensionDoorOrTeleport(location lTarget, bool bVisualsOnly = false) {
	if (GetAreaFromLocation(lTarget) == GetArea(OBJECT_SELF))
		SpellDimensionDoor(lTarget, bVisualsOnly);
	else
		SpellTeleport(lTarget, bVisualsOnly);
}


void DimensionDoorEffect(object oActivator, location lSource, location lTarget) {
	vector vSource = GetPositionFromLocation(lSource);
	vector vTarget = GetPositionFromLocation(lTarget);
	vSource.z += 0.9; vTarget.z += 0.9;
	location lElevatedSource = Location(GetAreaFromLocation(lSource), vSource, GetFacingFromLocation(lSource));
	location lElevatedTarget = Location(GetAreaFromLocation(lTarget), vTarget, GetFacingFromLocation(lTarget));
	
	int i;
	for (i = 76; i < 81; i++) {
		ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(i), lElevatedSource);
		ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(i), lElevatedTarget);
	}

	ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_FNF_SUMMON_UNDEAD), lTarget);
}

void TeleportEffect(object oActivator, location oLocation) {
	vector v = GetPositionFromLocation(oLocation);

	vector
	vFeet = v, vBody = v, vHead = v;
	vBody.z = vBody.z + 0.9;
	vHead.z = vBody.z + 0.9;

	location
		lFeet = Location(GetAreaFromLocation(oLocation), vFeet, 0.0),
		lBody = Location(GetAreaFromLocation(oLocation), vBody, 0.0),
		lHead = Location(GetAreaFromLocation(oLocation), vHead, 0.0);

	DelayCommand(0.0, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(
				VFX_IMP_SPELL_MANTLE_USE), oLocation));

	// feet
	DelayCommand(0.0, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_HEALING_G),
			lFeet));
	DelayCommand(0.2, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_HEALING_G),
			lFeet));
	DelayCommand(0.4, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_HEALING_G),
			lFeet));

	// body
	DelayCommand(0.2, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_HEALING_G),
			lBody));
	DelayCommand(0.4, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_HEALING_G),
			lBody));
	DelayCommand(0.6, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_HEALING_G),
			lBody));

	// head
	DelayCommand(0.4, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_HEALING_G),
			lHead));
	DelayCommand(0.6, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_HEALING_G),
			lHead));
	DelayCommand(0.8, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_HEALING_G),
			lHead));


	// nifty rings with cool whoop sound.
	DelayCommand(0.0, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_DEATH_WARD),
			oLocation));
	DelayCommand(0.5, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_DEATH_WARD),
			oLocation));
	DelayCommand(1.0, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_DEATH_WARD),
			oLocation));
	DelayCommand(1.2, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_DEATH_WARD),
			oLocation));

	DelayCommand(0.0, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_DEATH_WARD),
			lHead));
	DelayCommand(0.5, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_DEATH_WARD),
			lHead));
	DelayCommand(1.0, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_DEATH_WARD),
			lHead));
	DelayCommand(1.2, ApplyEffectAtLocation(DURATION_TYPE_INSTANT, EffectVisualEffect(VFX_IMP_DEATH_WARD),
			lHead));

}
