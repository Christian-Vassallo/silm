/*
  File: inc_chat_run.n
  
  TODO: translateme

Allgemeine Benutzung:
Alle Chatbefehle beginnen mit einem / vorangestellt. Sie nehmen optionale Parameter an, sowie Optionen. Benutzern von unixoiden Kommandozeilen-Shells duerfte dies sehr sehr bekannt vorkommen. 

Parameter:
Parameter werden hinter dem Befehl angefuegt, in der Reihenfolge, in der man sie dem Befehl uebergeben moechte; sie werden durch ein oder mehrere Leerzeichen getrennt. Wenn ein Parameter ein Leerzeichen enthaelt, so muss man den Parameter in einfache oder doppelte Anfuehrungszeichen setzen. 

Optionen:
Optionen sind, wie angedeutet, optionale Parameter. Sie beginnen immer mit einem vorangestellten -, und koennen optional einen Wert haben. Dies wird in der Uebersicht durch ein =Typ angedeutet. 
- Beispiel: h t=int 
Dies sagt aus, dass der Befehl eine Option "-h" versteht, sowie eine Option "-t int"; wo int eine beliebige Zahl ist, positiv oder negativ.

Typen:
- int: kommt von Integer, bedeutet eine Ganzzahl mit optionalem Vorzeichen 
- float: Fliesskommazahl - Dezimaltrenner ist ein ".", kein "," (55.42) 
- string: Eine Zeichenkette: --blubb "Dies ist das Argument zu blubb" 
- bool: Ein Ja/Nein-Wert. 1 oder 0, true oder false, yes oder no. 

Ziel eines Befehls:
Die meisten Befehle arbeiten mit einem Ziel. Dieses kann durch die Zielwahl (ein Gegenstand unter Selbst erstellt, Einfuehrung) getan werden, oder durch den Konsolenbefehl /ta. 
  
*/
extern("inc_chat")
extern("_gen")
extern("inc_events")
extern("inc_target")
extern("inc_chatcommand")
extern("inc_getopt")
extern("inc_chat_lib")

const string
COMMAND_SPLIT = "&&",
COMMAND_SPLIT_RX = "\s*&&\s*";



string
LastCommand;



int CommandModSet(object oPC, int iMode, int nRunLevel);
int CommandModHere(object oPC, int iMode, int nRunLevel);
int CommandModSelf(object oPC, int iMode, int nRunLevel);
int CommandModRadius(object oPC, int iMode, int nRunLevel);
int CommandModRectangle(object oPC, int iMode, int nRunLevel);
int CommandModLine(object oPC, int iMode, int nRunLevel);
int CommandModArea(object oPC, int iMode, int nRunLevel);
int CommandModServer(object oPC, int iMode, int nRunLevel);
int CommandModOnline(object oPC, int iMode, int nRunLevel);


int CommandSQL(object oPC, int iMode);


// This evaluates a string of commands, not prefixed with the
// command character.
// Example:  "ta self && app 298 && restore"
int CommandEval(object oPC, int iMode, string sText, int bRunMacro, int bRunAlias, int nRunModLevel);

// Runs a single command.  Usually called by CommandEval.
int RunCommand(object oPC, int iMode, string sText, int bRunMacro, int bRunAlias, int nRunModLevel);


int OnCommand(object oPC, string sCommand, string sArg, int iMode, int bRunMacro , int bRunAlias, int nRunModLevel);

void RunMacro(object oPC, int iMode, string sMacro);
int CommandMacro(object oPC, int iMode);


int GetIsMacro(object oPC, string sMacroName);

// Run this on module startup
void RegisterAllCommands();

void RegisterCommand(string sCommandName, string sOptions, int nMinArg = -1, int nMaxArg = -1);
void RegisterAlias(string sAlias, string sAliasValue);

void RegisterHelp(string sText, int nAMask = AMASK_ANY);

void RegisterAccessFlags(int nFlags);



int RunCommand(object oPC, int iMode, string sText, int bRunMacro, int bRunAlias, int nRunModLevel) {
	nRunModLevel = unsigned(nRunModLevel);
	string sCommand, sRest;

	sText = GetStringTrim(sText);

	// Now split up between command and the rest of arguments
	int iWhite = FindSubString(sText, " ");

	if ( iWhite > -1 ) {

		sCommand = GetStringLowerCase(GetSubString(sText, 0, iWhite));

		int i = 1;
		while ( GetSubString(sText, iWhite + i, 1) == " " )
			i++;

		sRest = GetSubString(sText, iWhite + i, GetStringLength(sText));

	} else {

		sCommand = GetStringLowerCase(GetSubString(sText, 0, 1024));
		sRest = "";

	}

	SetLocalString(oPC, "last_chat_command", sCommand);

	sCommand = GetStringTrim(sCommand);
	sRest = GetStringTrim(sRest);

	if (gvGetInt("chat_debug")) {
		SendMessageToAllDMs("chat> run(RunCommand): '" + sCommand + "':'" + sRest + "'::" + IntToString(iMode) + "::" + 
			IntToString(bRunMacro) + ":" + IntToString(bRunAlias) + ":" + IntToString(nRunModLevel));
	}

	switch ( OnCommand(oPC, sCommand, sRest, iMode, bRunMacro, bRunAlias, nRunModLevel) ) {
		case ACCESS:
			ToPC("Ihr habt nicht die noetigen Rechte, um diesen Befehl auszufuehren.", oPC);
			return FALSE;

		case SYNTAX:
			// ToPC(sCommand + ": Syntaxfehler, bitte ueberpruefen.", oPC);
			return FALSE;

		case NOTFOUND:
			if (gvGetInt("chat_debug")) {
				SendMessageToAllDMs("chat> NOTFOUND(RunCommand): '" + sCommand + "':'" + sRest + "'::" + IntToString(iMode) + "::" + 
					IntToString(bRunMacro) + ":" + IntToString(bRunAlias) + ":" + IntToString(nRunModLevel));
			}
			ToPC("Befehl nicht gefunden.", oPC);
			break;

		case FAIL:
			return FALSE;

		case OK:
			// Continue
			// break;
	}

	if ( GetLocalInt(oPC, "chat_suppress_audit") == 0 ) {
		string sData = GetLocalString(oPC, "chat_data_audit");
		SetLocalString(oPC, "chat_data_audit", "");
		audit(sCommand, oPC, audit_fields("args", ( sData ==
												   "" ? sRest : sData ), "mode", IntToString(iMode)),
			"command", GetTarget());
	} else
		SetLocalInt(oPC, "chat_suppress_audit", 0);
	return 1;
}


int CommandEval(object oPC, int iMode, string sText, int bRunMacro, int bRunAlias, int nRunModLevel) {
	nRunModLevel = unsigned(nRunModLevel);
	int i = 0;
	string sCmd = "";

	int nCommandCount = commandsplit(sText, COMMAND_SPLIT);

	if (gvGetInt("chat_debug")) {
		SendMessageToAllDMs("chat> CommandEval(): '" + sText + "'::" + IntToString(iMode) + "::" + 
			IntToString(nCommandCount) + "::" +
			IntToString(bRunMacro) + ":" + IntToString(bRunAlias) + ":" + IntToString(nRunModLevel));
	}

	for ( i = 0; i < nCommandCount; i++ ) {
		sCmd = commandget(i);
		if ( !RunCommand(oPC, iMode, sCmd, bRunMacro, bRunAlias, nRunModLevel) )
			return FALSE;
	}
	return TRUE;
}




void RegisterAlias(string sAlias, string sAliasValue) {
	SetLocalString(GetModule(), "alias_" + sAlias, sAliasValue);
}

void RA(string sAlias, string sAliasValue) {
	RegisterAlias(sAlias, sAliasValue);
}

void RegisterCommand(string sCommandName, string sOptions, int nMinArg = -1, int nMaxArg = -1) {
	object oM = GetModule();
	LastCommand = GetStringLowerCase(sCommandName);

	string sAllCommands = GetLocalString(oM, "cmds_all");
	if ( sAllCommands != "" )
		sAllCommands += ", ";
	sAllCommands += LastCommand;
	SetLocalString(oM, "cmds_all", sAllCommands);

	SetLocalInt(oM, "cmd_" + LastCommand, 1);
	SetLocalString(oM, "cmd_" + LastCommand + "_opt", sOptions);
	SetLocalInt(oM, "cmd_" + LastCommand + "_argc_min", nMinArg);
	SetLocalInt(oM, "cmd_" + LastCommand + "_argc_max", nMaxArg);

	SetLocalInt(oM, "cmd_" + LastCommand + "_amask", AMASK_GLOBAL_GM);
}

void RH(string sText, int nAMask = AMASK_ANY) {
	RegisterHelp(sText);
}

// Cough up a syntax helper
void RHs(string s = "", int bAddTarget = FALSE, int nAMask = AMASK_ANY) {
	RH("Syntax: " +
		LastCommand + " " + ( bAddTarget == TRUE ? "[-t=1.." + IntToString(TARGET_MAX) + "] " : "" ) + s);
}

// Display an example
void RHe(string s = "", int nAMask = AMASK_ANY) {
	RH("Example: " + LastCommand + " " + s);
}

void RegisterHelp(string sText, int nAMask = AMASK_ANY) {
	int nCount = GetLocalInt(GetModule(), "cmd_" + LastCommand + "_h");

	SetLocalString(GetModule(), "cmd_" + LastCommand + "h_" + IntToString(nCount), sText);
	SetLocalInt(GetModule(), "cmd_" + LastCommand + "_ham_" + IntToString(nCount), nAMask);

	nCount++;
	SetLocalInt(GetModule(), "cmd_" + LastCommand + "_h", nCount);
}

void RAF(int n) {
	RegisterAccessFlags(n);
}

void RegisterAccessFlags(int nFlags) {
	object oM = GetModule();
	SetLocalInt(oM, "cmd_" + LastCommand + "_amask", nFlags);
}


void RegisterAllCommands() {
	/* modifiers */
	
	// Chatcommand: g
	RegisterCommand("g", "");

	
	// Chatcommand: here
	RegisterCommand("here", "");
	
	
	// Chatcommand: self
	RegisterCommand("self", "");

	
	// Chatcommand: online
	RegisterCommand("online", "dms");
	RAF(AMASK_CAN_DO_BACKEND);

	
	// Chatcommand: area
	RegisterCommand("area", "type=");
	
	
	// Chatcommand: rect
	RegisterCommand("rect", "x= y= type=");

	
	// Chatcommand: radius
	RegisterCommand("radius", "r= type=");
	
	
	// Chatcommand: line
	RegisterCommand("line", "c=");
	
	
	// Chatcommand: server
	RegisterCommand("server", "type=");
	RAF(AMASK_CAN_DO_BACKEND);
	
	
	// Chatcommand: run
	// Runs a named script.
	RegisterCommand("run", "", 1, 1);
	RAF(AMASK_CAN_DO_BACKEND);


	/* public commands */

	// Chatcommand: m
	// Creates/Executes macros.
	RegisterCommand("m", "i d l", 1, 2);
	RHs("MacroName [MacroCode] >> Creates and executes macros");
	RHs("-l >> List all your macros");
	RHs("-d MacroName >> Delete a macro");
	RHs("-i MacroName >> Create a macroitem");

	RegisterCommand("bpop", "");
	RAF(AMASK_ANY);

	// Chatcommand: afk
	// Sets/unsets AFK status with shiny visuals.
	RegisterCommand("afk", "");
	RHs(">> Sets/unsets AFK mode (with flashy visuals!).");
	RAF(AMASK_ANY);
	
	RegisterCommand("repeat", "");
	RHs(">> Repeat the last spoken message in the current chat channel");
	RAF(AMASK_ANY);

	// Chatcommand: write
	// Writes text onto parchment.
	// Parameters:
	// - text
	RegisterCommand("write", "");
	RHs("text to write >> Writes text onto any parchment.");
	RAF(AMASK_ANY);

	// Chatcommand: password
	// Sets a new password for the current account.
	// Parameters:
	// - the new password
	RegisterCommand("password", "");
	RHs("password >> Sets a new password.");
	RAF(AMASK_ANY);

	// Chatcommand: status
	// Shows server-related information.
	RegisterCommand("status", "");
	RH("Shows various server-related information.");
	RAF(AMASK_ANY);

	// Chatcommand: ignore
	// Ignores an account name.
	// Parameters:
	// - Account
	RegisterCommand("ignore", "", 1, 1);
	RAF(AMASK_ANY);

	// Chatcommand: unignore
	// Unignores an account name.
	// Parameters:
	// - Account
	RegisterCommand("unignore", "", 1, 1);
	RAF(AMASK_ANY);
	
	// Chatcommand: uptime
	// Shows server uptime.
	RegisterCommand("uptime", "");
	RAF(AMASK_ANY);

	// Chatcommand: weather
	// Shows the current area weather.
	RegisterCommand("weather", "", 0, 0);
	RHs("Shows the current weather.");
	RAF(AMASK_ANY);

	// Chatcommand: v
	// Play a voice-chat.
	// /v for a list.
	RegisterCommand("v", "");
	RAF(AMASK_ANY);

	
	// Chatcommand: a
	// Play animations.
	// /a for a list.
	RegisterCommand("a", "");
	// Chatcommand: sit
	// Sit down.
	RA("sit", "a sit");
	// Chatcommand: kneel
	// Kneel down.
	RA("kneel", "a crouch");
	RA("crouch", "a crouch");
	RAF(AMASK_ANY);

	
	// Chatcommand: rt
	// Toggle track-reading.
	RegisterCommand("rt", "");
	RHs("Reads tracks.");
	RAF(AMASK_ANY);

	/* public-GM hybrids */

	
	// Chatcommand: follow
	// Follow the next character standing nearest to you.
	RegisterCommand("follow", "");
	RH("Follow the PC standing next to you.", AMASK_ANY);
	RHs("[target_0] [target_1]", AMASK_GM);
	RHe(">> Follow current target", AMASK_GM);
	RHe("[target_0] >> Make t_0 follow you", AMASK_GM);
	RHe("[target_0] [target_1] >> Make t_0 follow t_1", AMASK_GM);
	RAF(AMASK_ANY);

	
	// Chatcommand: lastlog
	// Show the last-said chat concerning you.
	RegisterCommand("lastlog", "count=");
	RHs("Zeigt die letzten Zeilen des Gebietschats an, soweit sie dich betreffen.", AMASK_ANY);
	RHs("[-count=20] >> Retrieves the last 15 lines of text spoken.", AMASK_GM);
	RAF(AMASK_CAN_SEE_CHATLOGS);

	/* GM commands */

	
	// Chatcommand: gi
	// Creates a command item for a named group.
	// Parameters:
	// - groupname
	RegisterCommand("gi", "", 1, 1);
	RHs("setname >> create item for setname");

	
	// Chatcommand: gs
	// Shows/selects a new named group.
	// Parameters:
	// - groupname
	RegisterCommand("gs", "", 0, 1);
	RHs("[setname] >> get/set current set");

	
	// Chatcommand: ga
	// Adds the current target to the current named group.
	RegisterCommand("ga", "s=", 0, 0);
	RHs("[-s=setname] >> add target to current/setname set");

	
	// Chatcommand: gc
	// Clears the current named group.
	RegisterCommand("gc", "s=", 0, 0);
	RHs("[-s=setname] >> clear current/setname set");

	
	// Chatcommand: n
	// Nudge target in direction.
	// Options:
	// - x=, y=, z=: float offset
	RegisterCommand("n", "x= y= z=", 0, 0);
	RHs("[-x=float] [-y=float] [-z=float] >> nudge current target in direction");


	
	// Chatcommand: go
	// Jump to named location.
	RegisterCommand("go", "", 1, 1);
	RHs("loc >> Go to location.");
	RAF(AMASK_ANY);
	
	// Chatcommand: re
	// Return to last location before /go
	RegisterCommand("re", "", 0, 0);
	RHs("Return to from whence you came.");
	RAF(AMASK_ANY);

	
	// Chatcommand: shun
	// Shuts an account up. Global.
	RegisterCommand("shun", "");
	
	// Chatcommand: unshun
	// Reverse of shun.
	RegisterCommand("unshun", "");

	
	// Chatcommand: fix
	// Fixes things. Developer only.
	RegisterCommand("fix", "", 1, 1);
	RHs("Fixes things.");

	
	// Chatcommand: obj
	// Manages objects.
	// Options:
	// - plot=: Set plot flag
	// - destroyable=: Set destroyable
	RegisterCommand("obj", "plot= destroyable=");

	
	// Chatcommand: tag
	// Gets/sets object tag.
	RegisterCommand("tag", "", 0, 1);
	
	// Chatcommand: description
	// Gets/sets object description.
	RegisterCommand("description", "", 0, 1);

	
	
	// Chatcommand: charges
	// Gets/sets the charges of the current target.
	RegisterCommand("charges", "", 0, 1);
	RHs("Gets/Sets the charges of the current item", 1);


	
	// Chatcommand: cr
	// Manages creatures.
	// Options:
	// - i=bool: set immortality flag
	// - c=: set commandable flag
	// - phenotype=int: set phenotype
	// - subrace=str: set subrace
	// - wings=int: set wings
	// - tail=int: set tail
	// - bp=: set bodypart
	// - portrait=str: set portrait
	// - race=str: set race
	// - gender=int: set GENDER_
	// - faction=int: set faction ID
	// - persist=bool: persist this creature
	// - inv: open inventory
	RegisterCommand("cr", "i= c= phenotype= subrace= wings= tail= bp= portrait= race= gender= faction= persist= inv", 0, 0);
	RAF(AMASK_GM);
	RH("ToDo.");

	
	// Chatcommand: app
	// Change appearance of current target.
	// Parameters:
	// - int: [id]
	RegisterCommand("app", "", 0, 1);
	RAF(AMASK_ANY);
	
	// Chatcommand: pht
	// Get/set phenotype. DEPRECATED, use /cr.
	// Parameters:
	// - int: [id]
	RegisterCommand("pht", "", 0, 1);
	RAF(AMASK_GM);
	
	// Chatcommand: subrace
	// Gets/changes subrace. DEPRECATED, use /cr.
	// Parameters:
	// - str: [new subrace]
	RegisterCommand("subrace", "d", 0, 1);
	RHs("[-d] [subr] >> Gets/Sets the subrace", 1);
	
	// Chatcommand: bp
	// Get/set bodypart.
	// Parameters:
	// - int: creature_part
	// - int: [new_value]
	RegisterCommand("bp", "", 1, 2);
	RHs("creature_part_const [newvalue] >> Sets a bodypart on the selected target", 1);
	RH("Check /showconst creature for a list of CREATURE_PARTs");
	RAF(AMASK_ANY);

	
	// Chatcommand: wings
	RegisterCommand("wings", "", 0, 1);
	RHs("[wing_type] >> Gets/Sets the wings on the selected target", 1);
	RAF(AMASK_ANY);

	
	// Chatcommand: tail
	RegisterCommand("tail", "", 0, 1);
	RHs("[tail_type] >> Gets/Sets the tail on the selected target", 1);
	RAF(AMASK_ANY);
	
	// Chatcommand: portrait
	RegisterCommand("portrait", "", 0, 1);
	RHs("[new_portrait_resref] >> Gets/Sets the portrait", 1);
	RAF(AMASK_ANY);

	
	// Chatcommand: it
	// Manages items.
	// Options:
	// - charges=int: Sets charges.
	// - droppable=bool: set droppable flag
	// - weight=int: set weight in tenth of lbs
	// - value=int: set value in copper coins
	RegisterCommand("it", "droppable= weight= value= plot=", 0, 0);
	RH("Shows/sets various item related things.");
	RHs("[--droppable=bool] [--weight=int] [--value=int] [--plot=bool]");

	
	// Chatcommand: pl
	// Manages placeables.
	// Options:
	// - persist=bool: persist
	// - useable=bool: set useable flag
	// - plot=bool: set plot flag
	// Parameters:
	// - str: [a new placeable scene text]
	RegisterCommand("pl", "useable= persist= plot=", 0, 1);
	RH("Shows/sets various placeable related things.");
	RHs("[--persist=bool] [--useable=bool] [--plot=bool] [placeable scene text]");

	
	// Chatcommand: rotate
	// Rotates object by degrees.
	RegisterCommand("rotate", "", 0, 1);
	RHs("[deg] >> Sets gets the rotation either as relative or absolute value.", 1);

	
	// Chatcommand: castspell
	// Cast a spell.
	RegisterCommand("castspell", "i mm= cl= dc= loc", 1, 1);
	RH("Casts a spell on the current target or location.");
	RHs("-loc >> Cast spell on location instead of target");
	RHs("-i >> Instant cast, no action queue.");
	RHs("-cl=N >> Specify caster level. Defaults to 1.");
	RHs("-dc=N >> Specify spell save DC. Defaults to engine value.");
	RHs("-mm=N >> Specify metamagic. empower=1 extend=2 maximize=4");
	RAF(AMASK_GLOBAL_GM);

	
	// Chatcommand: getdyepot
	// Returns a dye pot with the given color.
	RegisterCommand("getdyepot", "", 1, 2);

	
	// Chatcommand: bloodyhell
	RegisterCommand("bloodyhell", "", 0, 0);
	RH("For escapism");
	RAF(AMASK_CAN_DO_BACKEND);
	
	// Chatcommand: hp
	// Gets/sets HP.
	RegisterCommand("hp", "", 0, 1);
	RHs("[hp] >> Gets/Sets HP.", 1);

//	
	RegisterCommand("stat", "", 1, 1);
//	RHs("type >> type of (mentor, xp_dist)", 0);
//	RAF(AMASK_AUDIT);

	
	// Chatcommand: say
	// Say text.
	RegisterCommand("say", "");

	
	// Chatcommand: ta
	// Target something.
	RegisterCommand("ta", "n= tag= area= f= d l m=", 0, 1);
	RHs("[-f 1.." +
		IntToString(TARGET_MAX) +
		"] [-n n] type_of_target(one of: a(ny), ar(ea), pc, n(pc), h(ostile creature), p(laceable), d(oor), i(tem), w(aypoint), st(ore), t(rigger), aoe(area of effect), s(elf), pci(iterate all players), oi(iterate all objects in the area selected by --area), l(ocation, current))",
		1);
	RHs(
		"[-n n] [--area tag] [-m mask] oi >> Find nth object in Area designated by --area (or the current area) where the tag matches mask",
		1);
	RHs("[-n n] --tag Tag a >> Find nth object that has 'Tag' for tag", 1);
	RHs("-d new_default_slot >> Sets your default slot");
	RHs("-l >> List all currently selected targets");
	RAF(AMASK_GM);

	
	// Chatcommand: time
	// Gets/sets server time.
	RegisterCommand("time", "yr= mo= dy= hr= mn= sc=");
	RAF(AMASK_CAN_DO_BACKEND);

	
	// Chatcommand: rehash
	// Rehashes settings.
	RegisterCommand("rehash", "", 0, 0);
	RAF(AMASK_CAN_EDIT_GV);

	
	// Chatcommand: psql
	// Execute raw postgres query.
	RegisterCommand("psql", "", 1, 1);
	RAF(AMASK_CAN_DO_BACKEND);
	
	// Chatcommand: _sco
	// Store object with raw query.
	RegisterCommand("_sco", "", 1, 1);
	RAF(AMASK_CAN_DO_BACKEND);
	
	// Chatcommand: _rco
	// Receive object with raw query.
	RegisterCommand("_rco", "", 1, 1);
	RAF(AMASK_CAN_DO_BACKEND);

	
	// Chatcommand: createkey
	// Creates a key.
	// Parameters:
	// - str: tag of lock
	RegisterCommand("createkey", "app=", 0, 1);
	RHs("[--app=x] [name]", 0);


	
	// Chatcommand: lock
	// Manages locks.
	// Options:
	// - lockable=bool: set lockable flag
	// - locked=bool: set locked flag
	// - keytag=str: set tag of key
	// - keyreq=bool: set key_required flag
	// - lockdc=int: set lock DC
	// - unlockdc=int: set unlock dc
	RegisterCommand("lock", "lockable= locked= keytag= keyreq= lockdc= unlockdc=");
	RHs(
		"[--locked bool] [--lockable bool] [--keytag tag] [--keyreq bool] [--lockdc n] [--unlockdc n] >> Shows/sets options on a lock.",
		1);

	
	// Chatcommand: planewalk
	// Planewalk the current target.
	// Options:
	// - duration=float: duration in seconds
	// - plane=str: the target plane, or random if omitted
	RegisterCommand("planewalk", "plane= duration=");
	RHs(
		"[--duration f] [--plane plane] >> Makes the current target planewalk a random plane, or 'plane' for duration seconds, or 120.",
		1);


	
	// Chatcommand: help
	// Help .. useless ..
	RegisterCommand("help", "");
	RAF(AMASK_ANY);

	
	// Chatcommand: getrecipe
	// Get crafing recipe.
	// Parameters:
	// - int: id
	RegisterCommand("getrecipe", "", 1, 1);
	RHs("id >> Returns recipe with id", 0);
	RAF(AMASK_GLOBAL_GM);

	
	// Chatcommand: event
	// shows/sets event handlers.
	RegisterCommand("event", "", 0, 2);
	RH("Shows/sets event handlers.");
	RHs(">> Shows events.");
	RHs("eventname script >> Sets script for eventname.");
	RAF(AMASK_CAN_DO_BACKEND);

	// Chatcommand: effect
	// Create an effect on the current target.
	// Options:
	// - durtype=int: type of duration, defaults to permanent
	// - duration=int: time of duration, defaults to 0
	// - loc: create at location
	// - e: extraordinary
	// - s: supernatural
	// - r:
	// Parameters:
	// - effect-name
	// - [parameter] ..
	// - [n] ..
	// 
	// Available effects:
	// vfx(val) blind() damage(amount, type) deaf() dazed() death() confused() ethereal() knockdown() slow() stunned() timestop()
	// frightened() haste() curse(str, dex, con, int, wis, chr) polymorph(type locked=bool) acincrease(val) acdecrease(val) disease(type)
	// abilityincrease(ability, +) abilitydecrease(ability, -) seeinvis() trueseeing() ultravision() speedincrease(val) speeddecrease(val)
	// skillincrease(skill, val) skilldecrease(skill, val), cutsceneghost() dr(xx/x, type, limit) immunity(type) spellimmunity(school)
	// paralyze()
	RegisterCommand("effect", "durtype= duration= loc e s r l", 1, 50);
	RHs("[-durtype=] [-duration=] [-l] effectname >> Applys a effect on the selected target", 1);
	RHs(
		"[-durtype=] [-duration=] [-l] [-e] effectname >> Applys an extraordinary effect on the selected target (can be removed by resting, but not by dispel magic)",
		1);
	RHs(
		"[-durtype=] [-duration=] [-l] [-s] effectname >> Applys a supernatural effect on the selected target (can't be removed by resting or dispel magic)",
		1);
	RHs(" (Setting duration automagically sets durtype to 'temporary'.)");
	RHs("-r >> remove all effects from the selected target", 1);
	RH("Available Effects: ");
	RH(
		"vfx(val) blind() damage(amount, type) deaf() dazed() death() confused() ethereal() knockdown() slow() stunned() timestop() "
		+
		"frightened() haste() curse(str, dex, con, int, wis, chr) polymorph(type locked=bool) acincrease(val) acdecrease(val) disease(type) "
		+
		"abilityincrease(ability, +) abilitydecrease(ability, -) seeinvis() trueseeing() ultravision() speedincrease(val) speeddecrease(val) "
		+
		"skillincrease(skill, val) skilldecrease(skill, val), cutsceneghost() dr(xx/x, type, limit) immunity(type) spellimmunity(school) "
		+
		"paralyze()"
	);

	
	// Chatcommand: _xp
	// Sets/gets XP.
	RegisterCommand("_xp", "time");

	
	// Chatcommand: info
	// ??
	RegisterCommand("info", "");


	
	// Chatcommand: ar
	// Manages areas.
	// Options:
	// - rsl: recompute all static lightning
	// - explore: explore the area for the current target (player)
	// - tli [nc1 nc2]: get/set MainLight colors for the current tile
	// - tsi [nc1 nc2]: get/set SourceLight colors for the current tile
	RegisterCommand("ar", "rsl tli= tsi= explore");
	RHs("-rsl >> RecomputeStaticLighting() for the current area.");
	RHs("-explore >> Explores the area for the current target.");
	RHs("-tli [new_color_1] [new_color_2] >> Gets/Sets MainLight color for the current tile.");
	RHs("-tsi [new_color_1] [new_color_2] >> Gets/Sets SourceLight color for the current tile.");

	
	// Chatcommand: inspect
	// Show placeables that are persisted.
	RegisterCommand("inspect", "pl", 0, 0);
	RHs("-pl >> Show persistent placeables.");
	RAF(AMASK_CAN_SET_PERSISTENCY);


	
	// Chatcommand: so
	// Show objects within radius.
	// Options:
	// - type=int: object_type
	// Parameters:
	// - float: radius
	RegisterCommand("so", "type= m=");
	
	// Chatcommand: ko
	// KILLS objects within radius.
	// Options:
	// - type=int: object_type
	// Parameters:
	// - float: radius
	RegisterCommand("ko", "type= m=");

	
	// Chatcommand: setname
	// Set the name of the current target.
	RegisterCommand("setname", "");
	RAF(AMASK_ANY);
	
	// Chatcommand: f2s
	// Flesh2Stone the current target.
	RegisterCommand("f2s", "");

	
	// Chatcommand: s2f
	// Stone2Flesh the current target.
	RegisterCommand("s2f", "");

	
	// Chatcommand: fixfactions
	// Fix all factions for the current target.
	RegisterCommand("fixfactions", "");

	
	// Chatcommand: limbo
	RegisterCommand("limbo", "");

	
	// Chatcommand: gettargetchooser
	RegisterCommand("gettargetchooser", "");

	
	// Chatcommand: restore
	// Restore things to normal.
	// Options:
	// -e: remove normal effects
	// -s: remove normal, extraordinary, and supernatural effects
	// -l: heal fully
	// -r: allow resting
	RegisterCommand("restore", "s e? l r");
	RHs("[-e? ID] [-l] -[r] >> Restores a creature to working condition", 1);
	RHs("-r >> Allow immediate resting", 1);
	RHs("-l >> Heal fully", 1);
	RHs("-e [ID] >> Remove all effects, or effects of type ID", 1);
	RHs("-s >> Removes all effects, including supernatural effects.", 1);

	
	// Chatcommand: set
	// Set variable.
	RegisterCommand("set", "");
	
	// Chatcommand: get
	// Get variable.
	RegisterCommand("get", "");

	
	// Chatcommand: showconst
	// Show various constants.
	RegisterCommand("showconst", "");
	RHs(
		"type >> type of (mode, object, phenotype, creature, tail, wing, weather, polymorph, disease, class, duration, damage)");

	
	// Chatcommand: kill
	// Kill the current target (by self-applying damage)
	// Options:
	// -d: DestroyObject() instead of applying damage.
	RegisterCommand("kill", "d");
	
	// Chatcommand: create
	// Create something.
	RegisterCommand("create", "");

	
	// Chatcommand: kick
	// Kick an account or playername.
	RegisterCommand("kick", "");
	RAF(AMASK_GLOBAL_GM);

	
	// Chatcommand: vfx
	// Create an VFX
	RegisterCommand("vfx", "x= y= z=");


	
	// Chatcommand: fetch
	// Fetch the current target to yourself.
	RegisterCommand("fetch", "");
	RHs("[t1] [t2] [tn] >> Fetch those target slots, or fetch the current target to your location.");
	
	// Chatcommand: jump
	// Jump to the current target.
	// Options:
	// - loc: Jump to the current target-location instead of object.
	RegisterCommand("jump", "loc");
	RHs("[--loc] >> Jumps to target object or location", 1);
	
	// Chatcommand: cp
	// Copy the current object.
	RegisterCommand("cp", "", 0, 2);
	RHs("[amount=1] [string to eval]", 1);

	
	// Chatcommand: cpm
	// Copy a item and modify it.
	// CopyItemAndModify(Target, a, b, c, TRUE);
	RegisterCommand("cpm", "", 3, 3);
	RHs("a b c >> CopyItemAndModify(Target, a, b, c, TRUE);");
	RAF(AMASK_GLOBAL_GM);

	
	// Chatcommand: caq
	// clear the targets' action queue.
	RegisterCommand("caq", "");
	RHs(">> Clears the action queue.", 1);
	
	// Chatcommand: wwp
	// Make the targeted creature walk its waypoints.
	RegisterCommand("wwp", "");
	RHs(">> Makes a creature walk its designated day/night waypoints, or none if none were placed.", 1);
	
	// Chatcommand: rwalk
	// Make the targeted creature walk randomly.
	RegisterCommand("rwalk", "");
	RHs(">> Makes a creature walk randomly.", 1);

	RegisterCommand("playsound", "", 1, 1);
	RHs(">> Plays a sound file at your character location.");
	RAF(AMASK_ANY);
}



int OnCommand(object oPC, string sCommand, string sArg, int iMode, int bRunMacro, int bRunAlias, int nRunModLevel) {
	nRunModLevel = unsigned(nRunModLevel);

	if (gvGetInt("chat_debug")) {
		SendMessageToAllDMs("chat> run: '" + sCommand + "':'" + sArg + "'::" + IntToString(iMode) + "::" + 
			IntToString(bRunMacro) + ":" + IntToString(bRunAlias) + ":" + IntToString(nRunModLevel));
		SendMessageToAllDMs("chat> runs on: " + GetName(oPC) + " / " + GetName(OBJECT_SELF));
	}

	string sOpt = "";
	int nArgMin = 0;
	int nArgMax = 0;

	if ( bRunAlias ) {
		string sAlias = GetLocalString(GetModule(), "alias_" + sCommand);
		if ( "" != sAlias ) {
			return RunCommand(oPC, iMode, sAlias + " " + sArg, bRunMacro, FALSE, nRunModLevel);
		}
	}

	struct EventArguments cmdea;
	cmdea.a0 = GetStringTrim(sCommand);
	cmdea.a1 = GetStringTrim(sArg);
	int serial = GetEventSerial();
	int dispatch_ret = RunEventScriptsForWithArgv(serial, "chat_command", oPC, oPC, OBJECT_INVALID, GetLocation(OBJECT_INVALID), cmdea, EVENT_MODE_SYNC);
	DeleteEventArguments(serial);

	if (dispatch_ret & EVENT_RESULT_STOP) {
		// A plugin said its parsing it, stop it.
		if (dispatch_ret & EVENT_RESULT_FAIL)
			return FAIL;
		else
			return OK;
	}

	if ( GetLocalInt(GetModule(), "cmd_" + sCommand) ) {
		sOpt = GetLocalString(GetModule(), "cmd_" + sCommand + "_opt");
		nArgMin = GetLocalInt(GetModule(), "cmd_" + sCommand + "_argc_min");
		nArgMax = GetLocalInt(GetModule(), "cmd_" + sCommand + "_argc_max");
	} else {
		if (gvGetInt("chat_debug")) {
			SendMessageToAllDMs("chat> NOTFOUND(register): '" + sCommand + "':'" + sArg + "'::'" + IntToString(iMode) + "::" + 
				IntToString(bRunMacro) + ":" + IntToString(bRunAlias) + ":" + IntToString(nRunModLevel));
		}
		return NOTFOUND;
	}

	int nAMask = GetLocalInt(GetModule(), "cmd_" + sCommand + "_amask");

	if ( !GetLocalInt(GetModule(), "no_new_acl") && nAMask > 0 && !amask(oPC, nAMask) ) {
		if (gvGetInt("chat_debug")) {
			SendMessageToAllDMs("chat> NOACCESS(): " + sCommand + " " + sArg + IntToString(iMode) + "::" + 
				IntToString(bRunMacro) + ":" + IntToString(bRunAlias) + ":" + IntToString(nRunModLevel));
		}
		return ACCESS;
	}

	getopt_reset();
	if (!getopt_init(sArg, "h t= sleep= " + sOpt)) {
		ToPC("Error parsing arguments.");
		return SYNTAX;
	}

	if ( getopt_opt("h") && GetLocalInt(GetModule(), "cmd_" + sCommand) && (
			( nArgMin > -1 && getopt_argc() < nArgMin )
			|| ( nArgMax > -1 && getopt_argc() > nArgMax )
		) ) {
		ToPC("Falsche Anzahl an Parametern: Mindestens " +
			IntToString(nArgMin) + " und maximal " + IntToString(nArgMax));
		ToPC("Gib '/" + sCommand + " -h' ein fuer eine Hilfestellung zu diesem Befehl.");
		return SYNTAX;
	}

	if ( getopt_opt("h") ) {

		int nCount = GetLocalInt(GetModule(), "cmd_" + sCommand + "_h");
		int nDisp = 0;
		int i = 0;
		for ( i = 0; i < nCount; i++ ) {
			int nMask = GetLocalInt(GetModule(), "cmd_" + sCommand + "ham_" + IntToString(i));
			if ( amask(oPC, nMask) || nMask == 0 ) {
				ToPC(GetLocalString(GetModule(), "cmd_" + sCommand + "h_" + IntToString(i)));
				nDisp++;
			}
		}
		if ( !nDisp )
			ToPC("No help available for this command.");
		return SYNTAX;
	}


	float fWait = 0.0;

	if ( getopt_opt("sleep") ) {
		// Wait for w
		fWait = StringToFloat(getopt_optv("sleep"));
		fWait = fWait < 0.0 ? 0.0 : fWait;
		fWait = fWait > 120.0 ? 120.0 : fWait;
	}

	setsleep(fWait);

	int ret = 0;

	SetLocalString(GetModule(), "chat_current_command_name", sCommand);

	if ( "m" == sCommand && bRunMacro )
		ret = CommandMacro(oPC, iMode);

	if ( nRunModLevel > 0 ) {
		if ("g" == sCommand)
			ret = CommandModSet(oPC, iMode, nRunModLevel);
		
		if ("here" == sCommand)
			ret = CommandModHere(oPC, iMode, nRunModLevel);

		if ("self" == sCommand)
			ret = CommandModSelf(oPC, iMode, nRunModLevel);

		if ("online" == sCommand)
			ret = CommandModOnline(oPC, iMode, nRunModLevel);

		if ("radius" == sCommand)
			ret = CommandModRadius(oPC, iMode, nRunModLevel);

		if ("area" == sCommand)
			ret = CommandModArea(oPC, iMode, nRunModLevel);

		if ("server" == sCommand)
			ret = CommandModServer(oPC, iMode, nRunModLevel);
	}


	if ("run" == sCommand)
		ret = CommandRunScript(oPC, iMode);

	// Set management
	if ( "gi" == sCommand )
		ret = CommandManageSetItem(oPC, iMode);
	if ( "gs" == sCommand )
		ret = CommandManageSetSet(oPC, iMode);
	if ( "gc" == sCommand )
		ret = CommandManageSetClear(oPC, iMode);
	if ( "ga" == sCommand )
		ret = CommandManageSetAdd(oPC, iMode);

	if ( "event" == sCommand )
		ret = CommandEventHandler(oPC, iMode);

	if ( "it" == sCommand )
		ret = CommandItem(oPC, iMode);

	if ( "n" == sCommand )
		ret = CommandNudge(oPC, iMode);

	if ( "go" == sCommand )
		ret = CommandGo(oPC, iMode);
	
	if ( "re" == sCommand )
		ret = CommandGoReturn(oPC, iMode);
	
	if ( "psql" == sCommand )
		ret = CommandpSQL(oPC, iMode);
	if ( "_sco" == sCommand )
		ret = CommandSCO(oPC, iMode);
	if ( "_rco" == sCommand )
		ret = CommandRCO(oPC, iMode);
	
	if ( "inspect" == sCommand )
		ret = CommandInspect(oPC, iMode);

	if ( "rehash" == sCommand )
		ret = CommandRehash(oPC, iMode);

	if ( "fix" == sCommand )
		ret = CommandFix(oPC, iMode);

	if ( "rt" == sCommand )
		ret = CommandReadTracks(oPC, iMode);

	if ( "afk" == sCommand )
		ret = CommandAFK(oPC, iMode);
	
	if ( "bpop" == sCommand )
		ret = CommandBodyOperator(oPC, iMode);
	
	if ("repeat" == sCommand)
		ret = CommandRepeat(oPC, iMode);

	if ( "cr" == sCommand )
		ret = CommandCreature(oPC, iMode);

	if ( "obj" == sCommand )
		ret = CommandObject(oPC, iMode);

	if ( "pl" == sCommand )
		ret = CommandPlaceable(oPC, iMode);

	if ( "weather" == sCommand )
		ret = CommandShowWeather(oPC, iMode);

	if ( "tag" == sCommand )
		ret = CommandTag(oPC, iMode);

	if ( "description" == sCommand )
		ret = CommandDescription(oPC, iMode);

	if ( "castspell" == sCommand )
		ret = CommandCastSpell(oPC, iMode);

	if ( "getdyepot" == sCommand )
		ret = CommandGetDyePot(oPC, iMode);

	if ( "bloodyhell" == sCommand )
		ret = CommandOhHellBang(oPC, iMode);

	if ( "rotate" == sCommand )
		ret = CommandRotate(oPC, iMode);

	if ( "hp" == sCommand )
		ret = CommandHP(oPC, iMode);

//	if ( "stat" == sCommand )
//		ret = CommandStat(oPC, iMode);

	if ( "createkey" == sCommand )
		ret = CommandCreateKey(oPC, iMode);

	if ( "say" == sCommand )
		ret = CommandSay(oPC, iMode);

	if ( "write" == sCommand )
		ret = CommandWrite(oPC, iMode);


	if ( "time" == sCommand )
		ret = CommandTime(oPC, iMode);

	if ( "lock" == sCommand )
		ret = CommandLock(oPC, iMode);

	if ( "planewalk" == sCommand )
		ret = CommandPlaneWalk(oPC, iMode);


	if ( "getrecipe" == sCommand )
		ret = CommandGetRecipe(oPC, iMode);

	if ( "lastlog" == sCommand )
		ret = CommandLastLog(oPC, iMode);

	if ( "charges" == sCommand )
		ret = CommandCharges(oPC, iMode);

	if ( "effect" == sCommand )
		ret = CommandEffect(oPC, iMode);

	if ( "_xp" == sCommand )
		ret = CommandXP(oPC, iMode);

	if ( "info" == sCommand )
		ret = CommandInfo(oPC, iMode);

	if ( "password" == sCommand )
		ret = CommandPassword(oPC, iMode);

	if ( "status" == sCommand )
		ret = CommandStatus(oPC, iMode);

	if ( "ta" == sCommand )
		ret = CommandTarget(oPC, iMode);

	if ( "portrait" == sCommand )
		ret = CommandPortrait(oPC, iMode);

	if ( "bp" == sCommand )
		ret = CommandBodyPart(oPC, iMode);

	if ( "wings" == sCommand )
		ret = CommandWing(oPC, iMode);

	if ( "tail" == sCommand )
		ret = CommandTail(oPC, iMode);

	if ( "subrace" == sCommand )
		ret = CommandSubRace(oPC, iMode);

	if ( "ar" == sCommand )
		ret = CommandArea(oPC, iMode);


	if ( "shun" == sCommand )
		ret = CommandShunUnshun(oPC, iMode, 1);

	if ( "unshun" == sCommand )
		ret = CommandShunUnshun(oPC, iMode, 0);

	if ( "ignore" == sCommand )
		ret = CommandIgnoreList(oPC, iMode, 1);

	if ( "unignore" == sCommand )
		ret = CommandIgnoreList(oPC, iMode, 0);

	if ( "so" == sCommand )
		ret = CommandShowObj(oPC, iMode);

	if ( "ko" == sCommand )
		ret = CommandKillObj(oPC, iMode);

	if ( "setname" == sCommand )
		ret = CommandSetName(oPC, iMode);

	if ( "app" == sCommand )
		ret = CommandSetAppearance(oPC, iMode);

	if ( "pht" == sCommand )
		ret = CommandSetPhenotype(oPC, iMode);

	if ( "f2s" == sCommand )
		ret = CommandFleshToStone(oPC, iMode);

	if ( "s2f" == sCommand )
		ret = CommandStoneToFlesh(oPC, iMode);

	if ( "fixfactions" == sCommand )
		ret = CommandFixFactions(oPC, iMode);

	if ( "limbo" == sCommand )
		ret = CommandLimbo(oPC, iMode);

	if ( "gettargetchooser" == sCommand )
		ret = CommandGetTargetChooser(oPC, iMode);

	if ( "restore" == sCommand )
		ret = CommandRestore(oPC, iMode);

	if ( "set" == sCommand )
		ret = CommandSetVar(oPC, iMode);

	if ( "get" == sCommand )
		ret = CommandGetVar(oPC, iMode);


	if ( "showconst" == sCommand )
		ret = CommandShowConst(oPC, iMode);

	if ( "kill" == sCommand )
		ret = CommandKill(oPC, iMode);

	if ( "create" == sCommand )
		ret = CommandCreate(oPC, iMode);

	if ( "v" == sCommand )
		ret = CommandVoiceChat(oPC, getopt_args(), iMode);

	if ( "a" == sCommand )
		ret = CommandAnimation(oPC, getopt_args(), iMode);

	/* aliases for anim */
	if ( "sit" == sCommand )
		ret = CommandAnimation(oPC, "sit", iMode);

	if ( "meditate" == sCommand )
		ret = CommandAnimation(oPC, "meditate", iMode);

	if ( "sitcross" == sCommand )
		ret = CommandAnimation(oPC, "sitcross", iMode);

	if ( "dance" == sCommand )
		ret = CommandAnimation(oPC, "dance", iMode);

	if ( "kneel" == sCommand )
		ret = CommandAnimation(oPC, "kneel", iMode);

	if ( "lieleft" == sCommand )
		ret = CommandAnimation(oPC, "lieleft", iMode);

	if ( "lieright" == sCommand )
		ret = CommandAnimation(oPC, "lieright", iMode);

	/* end of alias list */

	if ( "kick" == sCommand )
		ret = CommandKick(oPC, iMode);

	if ( "vfx" == sCommand )
		ret = CommandVFX(oPC, iMode);

	if ( "fx" == sCommand )
		ret = CommandFX(oPC, iMode);


	if ( "fetch" == sCommand )
		ret = CommandFetch(oPC, iMode);

	if ( "jump" == sCommand )
		ret = CommandJump(oPC, iMode);

	if ( "cp" == sCommand )
		ret = CommandCopyObject(oPC, iMode);

	if ( "cpm" == sCommand )
		ret = CommandCopyMod(oPC, iMode);

	if ( "follow" == sCommand )
		ret = CommandFollow(oPC, iMode);

	if ( "caq" == sCommand )
		ret = CommandCAQ(oPC, iMode);


	if ( "wwp" == sCommand )
		ret = CommandWWP(oPC, iMode);


	if ( "rwalk" == sCommand )
		ret = CommandRandomWalk(oPC, iMode);

	if ("playsound" == sCommand)
		ret = CommandPlaySound(oPC, iMode);
	
	SetLocalString(GetModule(), "chat_current_command_name", "");

	// SendMessageToAllDMs("chat> NOTFOUND(call): " + sCommand + " " + sArg + IntToString(iMode) + "::" + 
	//	IntToString(bRunMacro) + ":" + IntToString(bRunAlias) + ":" + IntToString(nRunModLevel));

	return ret;
}





int GetIsMacro(object oPC, string sMacroName) {
	string sAID = IntToString(GetAccountID(oPC));
	pQ("select id from macro where account = " +
		sAID + " and macro = " + pE(sMacroName) + " limit 1;");
	return pF();
}


void RunMacro(object oPC, int iMode, string sMacro) {
	ToPC("Executing macro '" + sMacro + "'.");

	int nSlot = TARGET_MACRO_SLOT;

	if ( getopt_opt("t") )
		nSlot = GetTargetSlot();

	int nOldTarget = GetDefaultSlot();

	SetDefaultSlot(nSlot);

	CommandEval(oPC, iMode, sMacro, FALSE, TRUE, gvGetInt("s_modlevel_macro"));

	SetDefaultSlot(nOldTarget);

	ToPC("Done.");


}

int CommandMacro(object oPC, int iMode) {
	if ( !amask(oPC, AMASK_CAN_USE_MACROS) )
		return ACCESS;

	// create/update: macro "macroname" "macrovalue"
	// run: macro "macroname"
	// create item: macro -i "macroname"
	// delete: macro -d "macroname"


	string sAID = IntToString(GetAccountID(oPC));
	if ( "0" == sAID ) {
		ToPC("You have no Account ID.");
		return OK;
	}

	string sMacroName = GetStringLowerCase(getopt_arg(0));
	string sMacro = getopt_arg(1);


	if ( getopt_opt("d") ) {
		pQ("select id from macro where account = " +
			sAID + " and macro = " + pE(sMacroName) + " order by account desc limit 1;");
		if ( pF() ) {
			// Delete the macro
			pQ("delete from macro where account = " +
				sAID + " and macro = " + pE(sMacroName) + " limit 1;");
			ToPC("Macro '" + sMacroName + "' deleted.");
		} else {
			ToPC("Macro '" + sMacroName + "' not found (or not yours).");
			return FAIL;
		}

		return OK;
	}

	if ( getopt_opt("l") ) {
		pQ("select id,macro,command from macro where (account = " +
			sAID + " or account = 0) order by account desc;");
		int n = 0;
		while ( pF() ) {
			sMacroName = pG(2);
			sMacro = pG(3);
			ToPC(sMacroName + ": " + sMacro);
			n++;
		}
		ToPC(IntToString(n) + " macros displayed.");
		return OK;

	}

	if ( getopt_opt("i") ) {
		pQ("select command from macro where (account = " +
			sAID +
			" or account = 0) and macro = " + pE(sMacroName) + " order by account desc limit 1;");
		if ( !pF() ) {
			ToPC("Macro not found.");
			return FAIL;
		} else {
			sMacro = pG(1);
			object oI = CreateItemOnObject("macro", oPC, 1);
			SetName(oI, "Macro: " + sMacroName);
			SetLocalString(oI, "macro", sMacro);
			SetLocalInt(oI, "aid", StringToInt(sAID));
		}

		return OK;
	}


	if ( getopt_argc() == 1 ) {
		pQ("select command from macro where (account = " +
			sAID +
			" or account = 0) and macro = " + pE(sMacroName) + " order by account desc limit 1;");
		if ( !pF() ) {
			ToPC("Macro not found.");
			return FAIL;
		} else {
			sMacro = pG(1);
			DelayCommand(getsleep(), RunMacro(oPC, iMode, sMacro));
		}

	} else {
		// save new personal macro
		SetLocalString(oPC, "macro_" + sMacroName, sMacro);
		pQ("select id from macro where account = " +
			sAID + " and macro = " + pE(sMacroName) + " limit 1;");
		if ( pF() ) {
			string sID = pG(1);
			pQ("update macro set command = " + pE(sMacro) + " where id = " + sID + ";");
			ToPC(sMacroName + " updated.");
		} else {
			pQ("insert into macro (account, macro, command) values(" +
				sAID + ", " + pE(sMacroName) + ", " + pE(sMacro) + ");");
			ToPC(sMacroName + " saved.");
		}



	}

	return OK;
}



int CommandModSet(object oPC, int iMode, int nRunModLevel) {
	string sRest = getopt_arg(0);
	
	if (gvGetInt("chat_debug")) {
		SendMessageToAllDMs("chat:mod:self> " + sRest);
	}
	
	int nOldTarget = GetDefaultSlot();
	SetDefaultSlot(TARGET_MACRO_SLOT);
	
	string sSetName = GetCurrentSet(oPC);

	int nSz = GetSetSize(sSetName, oPC);
	int i;
	int ret;
	object t;
	for (i = 0; i < nSz; i++) {
		t = GetFromSet(sSetName, i, oPC);
		SetTarget(t);
		ret = CommandEval(oPC, iMode, sRest, 1, 1, nRunModLevel - 1);
		if (!ret)
			return FAIL;
	}
	
	SetDefaultSlot(nOldTarget);

	return OK;
}

int CommandModHere(object oPC, int iMode, int nRunModLevel) {
	string sRest = getopt_arg(0);
	
	int nOldTarget = GetDefaultSlot();
	SetDefaultSlot(TARGET_MACRO_SLOT);
	
	SetTargetLocation(GetLocation(oPC));
	
	if (gvGetInt("chat_debug")) {
		SendMessageToAllDMs("chat:mod:here> " + sRest);
	}
	
	int ret = CommandEval(oPC, iMode, sRest, 1, 1, nRunModLevel - 1);

	SetDefaultSlot(nOldTarget);

	return ret ? OK : FAIL;
}


int CommandModSelf(object oPC, int iMode, int nRunModLevel) {
	string sRest = getopt_arg(0);
	
	int nOldTarget = GetDefaultSlot();
	SetDefaultSlot(TARGET_MACRO_SLOT);
	
	SetTarget(oPC);
	
	if (gvGetInt("chat_debug")) {
		SendMessageToAllDMs("chat:mod:self> " + sRest);
	}
	
	int ret = CommandEval(oPC, iMode, sRest, 1, 1, nRunModLevel - 1);

	SetDefaultSlot(nOldTarget);
	// ClearTarget(oPC, TARGET_MACRO_SLOT);
	//
	return ret ? OK : FAIL;
}

int CommandModRadius(object oPC, int iMode, int nRunModLevel) {
	string sRest = getopt_arg(0);
	
	float radius = 6.0;
	int otype = OBJECT_TYPE_ALL;

	if (getopt_opt("r"))
		radius = StringToFloat(getopt_optv("r"));

	if (getopt_opt("type"))
		otype = StringToInt(getopt_optv("type"));

	if (gvGetInt("chat_debug"))
		SendMessageToAllDMs("chat:mod:radius> r = " + FloatToString(radius));
	
	int nOldTarget = GetDefaultSlot();
	SetDefaultSlot(TARGET_MACRO_SLOT);

	object oLoop = GetFirstObjectInShape(SHAPE_SPHERE, radius, GetLocation(oPC), FALSE, otype);
	while (GetIsObjectValid(oLoop)) {
		SetTarget(oLoop);
		if (!CommandEval(oPC, iMode, sRest, 1, 1, nRunModLevel - 1)) {
			if (gvGetInt("chat_debug"))
				SendMessageToAllDMs("chat:mod:radius> Eval() returned FALSE");
			return FAIL;
		}
		
		oLoop = GetNextObjectInShape(SHAPE_SPHERE, radius, GetLocation(oPC), FALSE, otype);
	}
	SetDefaultSlot(nOldTarget);

	return OK;
}

int CommandModRectangle(object oPC, int iMode, int nRunModLevel) {
	ToPC("mod:rect> Not in yet.");
	return FAIL;
}

int CommandModLine(object oPC, int iMode, int nRunModLevel) {
	ToPC("mod:line> Not in yet.");
	return FAIL;
}

int CommandModArea(object oPC, int iMode, int nRunModLevel) {
	string sRest = getopt_arg(0);
	int otype = OBJECT_TYPE_ALL;
	
	if (getopt_opt("type"))
		otype = StringToInt(getopt_optv("type"));
	
	int nOldTarget = GetDefaultSlot();
	SetDefaultSlot(TARGET_MACRO_SLOT);

	iterate_area(GetArea(oPC), oIterate,
		if (GetObjectType(oIterate) == otype) {
			SetTarget(oIterate);
			if (!CommandEval(oPC, iMode, sRest, 1, 1, nRunModLevel - 1)) {
				if (gvGetInt("chat_debug"))
					SendMessageToAllDMs("chat:mod:area> Eval() returned FALSE");
				return FAIL;
			}
		}
	);

	SetDefaultSlot(nOldTarget);

	return OK;
return FAIL;
}

int CommandModServer(object oPC, int iMode, int nRunModLevel) {
	ToPC("mod:server> Not in yet.");
	return FAIL;
}

int CommandModOnline(object oPC, int iMode, int nRunModLevel) { 
	string sRest = getopt_arg(0);
	
	int bDoDM = getopt_opt("dms");

	int nOldTarget = GetDefaultSlot();
	SetDefaultSlot(TARGET_MACRO_SLOT);

	iterate_players(oIterate,
		SetTarget(oIterate);
		
		if (gvGetInt("chat_debug")) {
			SendMessageToAllDMs("chat:mod:online> " + sRest + ": " + GetName(oIterate));
		}

		if (!CommandEval(oPC, iMode, sRest, 1, 1, nRunModLevel - 1)) {
			if (gvGetInt("chat_debug"))
				SendMessageToAllDMs("chat:mod:online> Eval() returned FALSE");
			return FAIL;
		}
		
		if (gvGetInt("chat_debug"))
			SendMessageToAllDMs("chat:mod:online> continuing.");
	);

	SetDefaultSlot(nOldTarget);

	return OK;
}


