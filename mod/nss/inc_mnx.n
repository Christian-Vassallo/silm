__sp_extern("inc_nwnx_func")
__sp_extern("inc_setting")

#define MNX_IP "127.0.0.1"
#define MNX_PORT "2800"
#define MNX_SEND_COMMAND "NWNX!MNX!SEND!RMNX!"

// This is in usec
#define MNX_SLEEP_STEP 30
#define MNX_MAX_TRIES 15

// This is in usec
#define MNX_DEFAULT_TIMEOUT 450


#define MNX_SUCCESS 0
// There was a timeout in the mnx core. Retry is advised.
#define MNX_ERR_TIMEOUT 1
// There was a temporary non-recoverable error. Throw an exception.
#define MNX_ERR_FATAL 2

// The backend spew an error message. This usually requires code fixing
// and is not recoverable.
#define MNX_ERR_BACKEND_ERROR 10

struct mnxRet {
	
	/**
	 * > 0 on error code,
	 * 0 on success
	 */
	int error;

	/*
	 * How many requests were made for the command to succeed.
	 */
	int tries;

	/**
	 * How long did we wait for this one?
	 */
	int usec_slept;

	/**
	 * The sequence ID in this command.
	 */
	int serial;

	string ret;
};

/**
 * Sends a synchronous command to the backend.
 * Returns a valid mnxRet struct.
 * Normally, you do not want to use this yourself, use
 * the wrapper mnx_synchronous_command() instead.
 */
struct mnxRet mnx_synchronous_command_nowait(string command, int serial, int resend);


/**
 * Sends a synchronous command to the backend,
 * and returns the reply, or an error if uTimeout is exceeded.
 * For a sane uTimeout value, use MNX_DEFAULT_TIMEOUT.
 */
struct mnxRet mnx_synchronous_command(string command, int uTimeout = MNX_DEFAULT_TIMEOUT);

/**
 * This just sends out command.
 * It does not ensure delivery, nor does handle errors.
 * Use this for non-critical things whereever possible (eg status announcements).
 * Always returns 0.
 */
int mnx_asynchronous_command(string command);

int mnx_asynchronous_command_nowait(string command, int serial);

/**
 * This just sends out command.
 * It does not ensure delivery, nor does handle errors.
 * Use this for non-critical things whereever possible (eg status announcements).
 * Does not generate a new serial = Does not request a reply.
 * Always returns 0.
 */
int mnx_asynchronous_command_noreply(string command);


// Escape all possibly dangerous chars in a string suitable for a mnx query.
string mnx_escape(string sString);
// Un-escape all possibly dangerous chars in a string suitable for a mnx query.
string mnx_unescape(string sString);

/**
 * Prepares a mnx query string for delivery. You should use this to hand something to
 * mnx_(a)synchronous_*. 
 */
string mnx_prepare_command(string command,
		string param1 = "", string param2 = "", string param3 = "", string param4 = "",
		string param5 = "", string param6 = "", string param7 = "", string param8 = "");

/**
 * Returns the next available Serial for this request.
 * This is used internally. Do NOT use it in your scripts.
 */
int mnx_generate_serial();

/**
 * Called by the init scripts to set up buffers and such.
 */
void mnxInit();



void mnxInit() {
	int i;
	string sMemory;

	for ( i = 0; i < 16; i++ )
		sMemory += "................................................................";

	SetLocalString(GetModule(), "MNX_buffer", sMemory);
	SetLocalString(GetModule(), "NWNX!MNX!OPEN!RMNX!", MNX_IP +
		":" + MNX_PORT + "                                ");
}



int mnx_generate_serial() {
	int last = GetLocalInt(GetModule(), "mnx_last_serial");

	last++;

	// Wrap around
/*	if (last > MNX_SERIAL_MAX)
		last = MNX_SERIAL_MIN;*/
	// Dont wrap around for now.

	SetLocalInt(GetModule(), "mnx_last_serial", last);

	return last;
}


struct mnxRet mnx_synchronous_command_nowait(string command, int serial, int resend = true) {
	struct mnxRet r;

	_DEBUG("mnx", 1, "mnx_synchronous_command(" + command + ")");

	if (resend)
		SetLocalString(GetModule(), MNX_SEND_COMMAND + itoa(serial) + "!" + command, GetLocalString(GetModule(), "MNX_buffer"));


	string reply = GetLocalString(GetModule(), MNX_SEND_COMMAND + itoa(serial) + "!" + command);
	
	_DEBUG("mnx", 1, "mnx_synchronous_command(" + command + "): " + reply);

	int code = StringToInt(GetSubString(reply, 0, 1));
	string message = GetSubString(reply, 1, GetStringLength(reply) - 1);
	// strip the mnx retval
	r.ret = message;

	/*
	 * possible retvals from nwnx_mnx
	 * 0: success, rest is answer from backend
	 * 1: select() timed out
	 * 2: recvfrom() failed
	 * 3: send() failed
	 * 5: configuration error
	 */

	/*
	 * possible retvals from rmnx
	 * valid result
	 * #ERR#message
	 */


	switch (code) {
		case 0:
			r.error = MNX_SUCCESS;
			if ("#ERR#" == substr(r.ret, 0, 4)) {
				r.ret = substr(r.ret, 4, strlen(r.ret));
				r.error = MNX_ERR_BACKEND_ERROR;
			} else {

				// There is a serial?
				int exclpos = strpos(r.ret, "!");
				if (-1 == exclpos) {
					r.error = MNX_ERR_BACKEND_ERROR;
					string msg = "The backend did not send back the serial for: " + r.ret;
					r.ret = msg;
					_FATAL(msg);
				} else {
					int theirserial = atoi(substr(r.ret, 0, exclpos));
					_DEBUG("mnx", 2, "serial compare: (theirs) " + itoa(theirserial) + " vs (ours) " + itoa(serial));
					if (theirserial != serial) {
						r.error = MNX_ERR_BACKEND_ERROR;
						string msg = "The backend did not send back the CORRECT serial for: " + r.ret;
						r.ret = msg;
						_ERROR(msg);
					}
				}


				r.ret = mnx_unescape(r.ret);
			}
			break;

		case 1:
			r.error = MNX_ERR_TIMEOUT;
			break;

		case 2:
		case 3:
		case 5:
			r.error = MNX_ERR_FATAL;
			break;
	}

	return r;
}

struct mnxRet mnx_synchronous_command(string command, int uTimeout = MNX_DEFAULT_TIMEOUT) {
	struct mnxRet r;

	int serial = mnx_generate_serial();

	int tries = 1;
	int slept = 0;

	do {
		// only resend each third try to avoid backend spam
		r = mnx_synchronous_command_nowait(command, serial, (tries > 0 && tries % 3 == 0));
		
		// We got it. Yay.
		if (MNX_SUCCESS == r.error)
			break;

	
		// This totally borked up. Escalate.
		if (MNX_ERR_FATAL == r.error)
			break;

		// Unknown error code? All other cases covered.
		if (MNX_ERR_TIMEOUT != r.error) {
			_FATAL("Unknown return value: " + IntToString(r.error) + ", message = " + r.ret);
			break;
		}
		
		// We're giving up now.
		if (tries > MNX_MAX_TRIES || slept > uTimeout) {
			r.error = MNX_ERR_FATAL;
			r.ret = "permanent timeout while contacting backend";
			break;
		}

		// else sleep and try again!
		usleep(MNX_SLEEP_STEP);

		tries++;
		slept += MNX_SLEEP_STEP;

	} while (true);
	
	r.tries = tries;
	r.usec_slept = slept;
	r.serial = serial;

	return r;
}


int mnx_asynchronous_command_nowait(string command, int serial) {
	SetLocalString(GetModule(), MNX_SEND_COMMAND + itoa(serial) + "!" + command, GetLocalString(GetModule(), "MNX_buffer"));
	return 0;
}

int mnx_asynchronous_command_noreply(string command) {
	return mnx_asynchronous_command_nowait(command, 0);
}

int mnx_asynchronous_command(string command) {
	return mnx_asynchronous_command_nowait(command, mnx_generate_serial());
}


string mnx_escape(string sString) {
	if ( FindSubString(sString, "!") == -1 )  // not found
		return sString;

	int i;
	string sReturn = "";
	string sChar;

	// Loop over every character and replace special characters
	for ( i = 0; i < GetStringLength(sString); i++ ) {
		sChar = GetSubString(sString, i, 1);
		if ( sChar == "!" )
			sReturn += "#EXCL#";
		else
			sReturn += sChar;
	}
	return sReturn;
}

string mnx_unescape(string sString) {
	if ( FindSubString(sString, "#EXCL#") == -1 ) {
		return sString;
	}

	int i;
	string sReturn = "";
	string sChar;

	// Loop over every character and replace special characters
	for ( i = 0; i < GetStringLength(sString); i++ ) {
		sChar = GetSubString(sString, i, 6);
		if ( sChar == "#EXCL#" ) {
			sReturn += "!";
			i += 5;
		} else
			sReturn += GetSubString(sString, i, 1);
	}

	return sReturn;
}


string mnx_prepare_command(string command,
		string param1 = "", string param2 = "", string param3 = "", string param4 = "",
		string param5 = "", string param6 = "", string param7 = "", string param8 = "") {

	string str = mnx_escape(command);
	if ( param1 != "" )
		str += "!" + mnx_escape(param1);
	if ( param2 != "" )
		str += "!" + mnx_escape(param2);
	if ( param3 != "" )
		str += "!" + mnx_escape(param3);
	if ( param4 != "" )
		str += "!" + mnx_escape(param4);
	if ( param5 != "" )
		str += "!" + mnx_escape(param5);
	if ( param6 != "" )
		str += "!" + mnx_escape(param6);
	if ( param7 != "" )
		str += "!" + mnx_escape(param7);
	if ( param8 != "" )
		str += "!" + mnx_escape(param8);

	return str;
}
